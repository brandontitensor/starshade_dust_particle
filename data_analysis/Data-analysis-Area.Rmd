---
title: "Area_based_analysis"
author: "Brandon Titensor"
date: "2025-01-08"
output: pdf_document
---

```{r setup, include=FALSE}
# Load required libraries
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(tidyverse)
library(knitr)
library(rstatix)
library(ggpubr)
library(gridExtra)
library(data.table)
library(cowplot)
library(ggplot2)
library(dplyr)
library(grid)
library(fs)
library(png)

# Create unified theme
custom_theme <- theme_minimal() +
  theme(
    plot.title = element_text(size = 12, face = "bold", hjust = 0.5),
    plot.subtitle = element_text(size = 10, hjust = 0.5),
    axis.title = element_text(size = 10),
    axis.text = element_text(size = 8),
    legend.position = "bottom",
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_line(color = "gray95")
  )

# Define consistent color palette
trial_colors <- c(
  "6" = "#E41A1C",  # red
  "7" = "#FF7F00",  # orange
  "8" = "#377EB8",  # blue
  "9" = "#4DAF4A",  # green
  "10" = "#984EA3", # purple
  "11" = "#CEB180"  # tan
)

# Define consistent line types
line_types <- c(
  "Observed" = "solid",
  "Modeled" = "dashed",
  "Calibration" = "dotted"
)


```

## 1. Data Loading and Preprocessing

### 1.1 Edge Data

```{r load_edge_data}
# Function to load and process a single sample of edge data
load_sample_data <- function(sample_number) {
  # Format sample number with leading zeros
  sample_str <- sprintf("%02d", sample_number)
  
  # Construct file paths for particles and summary data
  particles_path <- sprintf("/Volumes/Extreme SSD/Research/Dust_Contamination/Trials/Data/Edges/Edge Measurements/Bef_%s minus Aft_%s/Particles Bef_%s minus Aft_%s.csv", 
                          sample_str, sample_str, sample_str, sample_str)
  summary_path <- sprintf("/Volumes/Extreme SSD/Research/Dust_Contamination/Trials/Data/Edges/Edge Measurements/Bef_%s minus Aft_%s/Summary Bef_%s minus Aft_%s_updated.csv", 
                         sample_str, sample_str, sample_str, sample_str)
  
  # Load and preprocess particle data
  particles_data <- read.csv(particles_path)
  particles_data$Sample <- sample_number
  
  # Load and preprocess summary data
  summary_data <- read.csv(summary_path)
  summary_data <- summary_data[,-c(8:11)]
  names(summary_data) <- make.names(names(summary_data))
  summary_data$Count <- as.numeric(gsub("[^0-9.]", "", summary_data$Count))
  summary_data$width <- as.numeric(gsub("[^0-9.]", "", summary_data$width))
  summary_data <- summary_data %>% drop_na()
  summary_data$Sample <- sample_number
  
  # Convert width from pixels to microns
  summary_data$width <- summary_data$width * (50/240)
  
  list(particles = particles_data, summary = summary_data)
}

# Load data for samples 36-50 (Trials 6-10, 5 samples each)
edge_data <- map(c(36:55), load_sample_data)

# Combine all particle data
edge_particles_data <- bind_rows(map(edge_data, "particles"))

# Combine all summary data
edge_summary_data <- bind_rows(map(edge_data, "summary"))

# Assign trials to samples (5 samples per trial)
edge_particles_data$Trial <- ceiling((edge_particles_data$Sample - 5) / 5) + 1
edge_summary_data$Trial <- ceiling((edge_summary_data$Sample - 5) / 5) + 1

# Calculate total width for each trial
total_width_by_trial <- edge_summary_data %>%
  group_by(Trial) %>%
  summarise(Total_Width = sum(width))

# Calculate the normalization factor
max_width <- max(total_width_by_trial$Total_Width)
normalization_factors <- max_width / total_width_by_trial$Total_Width
```

### 1.2 Surface Data

```{r load_surface_data}
# Function to load and process surface data
load_data <- function(condition) {
  # Function to load and process particle data for a single sample
  load_particle_data <- function(trial_number, sample_number, cond) {
    tryCatch({
      particle_path <- sprintf("/Volumes/Extreme SSD/Research/Dust_Contamination/Trials/Data/Surfaces/%sTr%dSa%dSurf/Particles_%sTr%dSa%dSurf.csv", 
                             cond, trial_number, sample_number, cond, trial_number, sample_number)
      
      particle_data <- read_csv(particle_path)
      particle_data <- particle_data[, 2:(ncol(particle_data)-2)]
      particle_data$Sample <- sample_number
      particle_data$Trial <- trial_number
      
      return(particle_data)
    }, error = function(e) {
      message(sprintf("Error loading particle data for %s Trial %d, Sample %d: %s", 
                     cond, trial_number, sample_number, e$message))
      return(NULL)
    })
  }

  # Load and process summary data
  load_summary_data <- function(trial_number, sample_number, cond) {
    tryCatch({
      summary_path <- sprintf("/Volumes/Extreme SSD/Research/Dust_Contamination/Trials/Data/Surfaces/%sTr%dSa%dSurf/Summary_%sTr%dSa%dSurf.csv", 
                            cond, trial_number, sample_number, cond, trial_number, sample_number)
      
      summary_data <- read_csv(summary_path, col_select = c(1, 2, 3, 5))
      names(summary_data) <- make.names(names(summary_data))
      summary_data <- summary_data %>% 
        drop_na() %>%
        mutate(
          Sample = sample_number,
          Trial = trial_number,
          Slice_Number = as.integer(substr(Slice, nchar(Slice)-6, nchar(Slice)-4))
        )
      
      return(summary_data)
    }, error = function(e) {
      message(sprintf("Error loading summary data for %s Trial %d, Sample %d: %s", 
                     cond, trial_number, sample_number, e$message))
      return(NULL)
    })
  }

  # Load data for trials 8-11
  surface_particle_data <- map2(rep(8:11, each = 5), rep(1:5, times = 4), 
                              ~load_particle_data(.x, .y, condition))
  surface_summary_data <- map2(rep(8:11, each = 5), rep(1:5, times = 4), 
                             ~load_summary_data(.x, .y, condition))

  # Combine all data
  surface_particle_data <- bind_rows(surface_particle_data)
  surface_summary_data <- bind_rows(surface_summary_data)

  # Add cleaning method information
  add_cleaning_method <- function(data) {
    data %>%
      mutate(Cleaning_Method = case_when(
        Trial %in% c(2, 3) ~ "IPA rinse",
        Trial %in% c(4, 5) ~ "Drag and wipe",
        Trial %in% c(6, 7) ~ "First contact",
        Trial %in% c(8, 9, 10, 11) ~ "First contact & Drag and wipe",
        TRUE ~ NA_character_
      ))
  }

  surface_particle_data <- add_cleaning_method(surface_particle_data)
  surface_summary_data <- add_cleaning_method(surface_summary_data)

  # Calculate imaged areas
  image_size <- 600 * 450 # microns^2
  trial_areas <- surface_summary_data %>%
    group_by(Trial, Cleaning_Method) %>%
    summarise(
      Total_Images = n(),
      Total_Area = Total_Images * image_size * 1e-12, # Convert to m^2
      .groups = "drop"
    )

  list(particle_data = surface_particle_data, 
       summary_data = surface_summary_data, 
       trial_areas = trial_areas)
}

# Load before and after surface data
surface_before_data <- load_data("Bef")
surface_after_data <- load_data("Aft")
```
### 1.3 Calibration Wafer Data

```{r load_calibration_data}
# Function to load and process calibration wafer data
load_calibration_data <- function(sample_number) {
  # Format sample number with leading zeros
  sample_str <- sprintf("%02d", sample_number)
  
  # Construct file paths
  particles_path <- sprintf("/Volumes/Extreme SSD/Research/Dust_Contamination/Trials/Data/Calibration/Edge Measurements/Bef_%s minus Aft_%s/Particles_Reanalysis_Bef_%s minus Aft_%s.csv", sample_str, sample_str, sample_str, sample_str)
  summary_path <- sprintf("/Volumes/Extreme SSD/Research/Dust_Contamination/Trials/Data/Calibration/Edge Measurements/Bef_%s minus Aft_%s/Summary_Reanalysis_Bef_%s minus Aft_%s_updated.csv", sample_str, sample_str, sample_str, sample_str)
  
  # Load particle data
  particles_data <- read.csv(particles_path)
  particles_data$Sample <- sample_number
  
  # Load summary data
  summary_data <- read.csv(summary_path)
  names(summary_data) <- make.names(names(summary_data))
  summary_data$Count <- as.numeric(gsub("[^0-9.]", "", summary_data$Count))
  summary_data$width <- as.numeric(gsub("[^0-9.]", "", summary_data$width))
  summary_data$Sample <- sample_number
  summary_data <- summary_data %>% drop_na()
  
  list(particles = particles_data, summary = summary_data)
}

# Load data for calibration samples (11-25)
calibration_data <- map(c(11:30), load_calibration_data)

# Combine all particle data
calibration_particles_data <- bind_rows(map(calibration_data, "particles"))

# Combine all summary data
calibration_summary_data <- bind_rows(map(calibration_data, "summary"))

# Assign trials to samples
calibration_particles_data$Trial <- ceiling((calibration_particles_data$Sample - 5) / 5) + 1
calibration_summary_data$Trial <- ceiling((calibration_summary_data$Sample - 5) / 5) + 1

# Calculate total width and normalization factors
total_width_by_trial <- calibration_summary_data %>%
  group_by(Trial) %>%
  summarise(Total_Width = sum(edge_width))

calibration_max_width <- max_width
calibration_normalization_factors <- calibration_max_width / total_width_by_trial$Total_Width

rm(calibration_data)
```

## 2. Surface Area Distribution Analysis

```{r surface_area_distribution_analysis}
surface_before_particles <- surface_before_data$particle_data %>%
  filter(Area > 1)
surface_after_particles <- surface_after_data$particle_data %>%
  filter(Area > 1)
combined_surface_data <- bind_rows(surface_before_particles,surface_after_particles)

# Create diameter thresholds
min_area <- 1  # Starting from 1 as per previous filter
max_area <- max(combined_surface_data$Area)
log_min <- log10(min_area)
log_max <- log10(max_area)

# Create 100 evenly spaced points on log scale
area_thresholds <- 10^(seq(log_min, log_max, length.out = 250))

#area_thresholds <- seq(1, max(combined_surface_data$Area), by = 10)

# Define IEST standard parameters and calculate sample areas
slope <- -0.926
image_size <- 600 * 450 
new_sample_areas <- surface_before_data$summary_data %>%
  group_by(Sample, Trial, Cleaning_Method) %>%
  summarise(
    Total_Images = n(),
    Total_Area = n() * image_size * 1e-12,  # Convert to m^2
    .groups = "drop"
  )


# Function to get area-based counts
get_area_counts <- function(data, normalization_factor) {
  sapply(area_thresholds, function(x) {
    sum(data$Area > x) * normalization_factor
  })
}



# Calculate area-based counts for before and after data
surface_before_counts <- surface_before_data$particle_data %>%
  group_by(Trial, Sample) %>%
  group_modify(~ {
    norm_factor <- 0.1 /  new_sample_areas$Total_Area[new_sample_areas$Sample == .y$Sample &  new_sample_areas$Trial == .y$Trial]
    counts <- get_area_counts(.x, norm_factor)
    tibble(
      Area = area_thresholds,
      Count = counts
    )
  })

surface_after_counts <- surface_after_data$particle_data %>%
  group_by(Trial, Sample) %>%
  group_modify(~ {
    norm_factor <- 0.1 /  new_sample_areas$Total_Area[new_sample_areas$Sample == .y$Sample &  new_sample_areas$Trial == .y$Trial]
    counts <- get_area_counts(.x, norm_factor)
    tibble(
      Area = area_thresholds,
      Count = counts
    )
  })

# Calculate differences and averages
surface_count_diff <- surface_after_counts %>%
  full_join(surface_before_counts, 
            by = c("Trial", "Sample", "Area"), 
            suffix = c("_After", "_Before")) %>%
  mutate(Count_Diff = Count_After - Count_Before,
         Positive_Diff = pmax(Count_Diff, 0))

# Calculate average counts by trial
average_surface_counts <- surface_count_diff %>%
  group_by(Trial, Area) %>%
  summarize(
    Average_Count = mean(Positive_Diff, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Average_Count),
         log_count = ifelse(log_count < 0, 0, log_count))

# Calculate best fit lines
surface_best_fits <- average_surface_counts %>%
  group_by(Trial) %>%
  filter(Average_Count > 0) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Average_Count),
         log_count = ifelse(log_count < 0, 0, log_count)) %>%
  summarise(
    slope = coef(lm(log_count ~ log_area))[2],
    intercept = coef(lm(log_count ~ log_area))[1],
    .groups = "drop"
  ) %>%
  mutate(PCL = 10^(-intercept/slope))

# For cumulative data - calculate the overall average across all trials
overall_average_surface <- average_surface_counts %>%
  group_by(log_area) %>%
  summarize(
    Average_Count = mean(log_count, na.rm = TRUE),
    .groups = "drop"
  )

# Modify the cumulative distribution plot
ggplot() +
  geom_line(data = average_surface_counts,
            aes(x = log_area, y = log_count, 
                color = factor(Trial))) +
  geom_line(data = overall_average_surface,
            aes(x = log_area, y = Average_Count),
            color = "black", size = 1.2) +  # Add distinct average line
  geom_abline(data = surface_best_fits,
              aes(slope = slope, intercept = intercept, 
                  color = factor(Trial)),
              linetype = "dotted") +
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(log[10](Area)~"(square microns)"),
    y = "log10(Particle Count)",
    title = "Surface Analysis: Particle Area Distribution",
    subtitle = "Solid lines: observed data, Dotted lines: fitted curves, Black line: overall average"
  ) +
  custom_theme

# Display PCL and slope statistics
kable(surface_best_fits, 
      caption = "PCL and Slope Statistics for Surface Analysis")

average_surface_binned <- average_surface_counts %>%
  group_by(Trial) %>%
  arrange(desc(Area)) %>%  # Ensure data is sorted by descending area
  mutate(
    Count = c(Average_Count[1], diff(Average_Count))  # First value is the total, then differences
  ) %>%
  ungroup() %>% 
  mutate(log_count_bin = log10(Count),
         log_count_bin = ifelse(log_count_bin < 0, 0, log_count_bin))

# Calculate overall average binned counts
overall_average_surface_binned <- average_surface_binned %>%
  group_by(Area) %>%
  summarize(
    Average_Count = mean(Count, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    log_area = log10(Area),
    log_count = log10(Average_Count),
    log_count = ifelse(log_count < 0 | !is.finite(log_count), 0, log_count)
  )

# Modify the binned distribution plot
ggplot() +
  geom_line(data = average_surface_binned, 
            aes(x = log_area, y = log_count_bin, 
                color = factor(Trial))) +
  geom_line(data = overall_average_surface_binned,
            aes(x = log_area, y = log_count),
            color = "black", size = 1.2) +  # Add distinct average line
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(Area~"(square microns)"),
    y = "Average Particle Count",
    title = "Surface Analysis: Binned Particle Size Distribution",
    subtitle = "Particles binned by area thresholds\nBlack line: overall average"
  ) +
  custom_theme +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "bottom"
  )
```

## 3. Edge Area Distribution Analysis

```{r edge_area_distribution_analysis}
new_edge_factors<- edge_summary_data %>%
  group_by(Sample, Trial) %>%
  summarise(
    Total_Width = sum(width),
    .groups = "drop"
  )

max_width <- max(new_edge_factors$Total_Width)

new_edge_factors <- new_edge_factors %>% 
  mutate(Factors = max_width/Total_Width)

# Calculate area-based counts for edge data
edge_counts <- edge_particles_data %>%
  group_by(Trial, Sample) %>%
  group_modify(~ {
    norm_factor <- new_edge_factors$Factors[new_edge_factors$Sample == .y$Sample & new_edge_factors$Trial == .y$Trial]
    counts <- get_area_counts(.x, norm_factor)
    tibble(
      Area = area_thresholds,
      Count = counts
    )
  })

# Calculate cumulative counts
cumulative_edge_counts <- edge_counts %>%
  group_by(Trial, Sample) %>%
  arrange(desc(Area)) %>%
  mutate(Cumulative_Count = cumsum(Count)) %>%
  ungroup()

# Calculate average counts by trial
average_edge_counts <- cumulative_edge_counts %>%
  group_by(Trial, Area) %>%
  summarize(
    Average_Count = round(mean(Cumulative_Count, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Average_Count),
         log_count = ifelse(log_count < 0, 0, log_count)) %>% 
  arrange(Trial, desc(Area)) 

# Calculate best fit lines
edge_best_fits <- average_edge_counts %>%
  group_by(Trial) %>%
  mutate(
    log_area = log10(Area),
    log_count = log10(Average_Count),
    log_count = ifelse(log_count < 0, 0, log_count)
  ) %>%
  summarise(
    slope = coef(lm(log_count ~ log_area))[2],
    intercept = coef(lm(log_count ~ log_area))[1],
    .groups = "drop"
  ) %>%
  mutate(PCL = 10^(-intercept/slope))

# For cumulative data - calculate the overall average across all trials
overall_average_cumulative <- average_edge_counts %>%
  group_by(log_area) %>%
  summarize(
    Average_Count = mean(log_count, na.rm = TRUE),
    .groups = "drop"
  )

# Modify the cumulative distribution plot
ggplot() +
  geom_line(data = average_edge_counts,
            aes(x = log_area, y = log_count,
                color = factor(Trial))) +
  geom_line(data = overall_average_cumulative,
            aes(x = log_area, y = Average_Count),
            color = "black", size = 1.2) +  # Make the average line distinct
  geom_abline(data = edge_best_fits,
              aes(slope = slope, intercept = intercept,
                  color = factor(Trial)),
              linetype = "dotted") +
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(log[10](Area)~"(square microns)"),
    y = "log10(Particle Count)",
    title = "Edge Analysis: Particle Area Distribution",
    subtitle = "Solid lines: observed data, Dotted lines: fitted curves, Black line: overall average"
  ) +
  custom_theme

# Display edge analysis statistics
kable(edge_best_fits %>%
        select(Trial, PCL, slope),
      caption = "Edge Analysis Summary Statistics")

# Calculate binned counts from cumulative data
edge_binned <- average_edge_counts %>%
  group_by(Trial) %>%
  arrange(desc(Area)) %>%  # Ensure data is sorted by descending area
  mutate(
    Count = c(Average_Count[1], diff(Average_Count))  # First value is the total, then differences
  ) %>%
  ungroup() %>% 
  mutate(log_count_bin = log10(Count),
         log_count_bin = ifelse(log_count_bin < 0, 0, log_count_bin))

# Calculate overall average binned counts
overall_average_binned <- edge_binned %>%
  group_by(Area) %>%
  summarize(
    Average_Count = mean(Count, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    log_area = log10(Area),
    log_count = log10(Average_Count),
    log_count = ifelse(log_count < 0 | !is.finite(log_count), 0, log_count)
  )

# Modify the binned distribution plot
ggplot() +
  geom_line(data = edge_binned, 
            aes(x = log_area, y = log_count_bin, 
                color = factor(Trial))) +
  geom_line(data = overall_average_binned,
            aes(x = log_area, y = log_count),
            color = "black", size = 1.2) +  # Make the average line distinct
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(log10Area~"(square microns)"),
    y = "log10(Average Particle Count)",
    title = "Edge Analysis: Binned Particle Size Distribution",
    subtitle = "Particles binned by logarithmic area thresholds\nBlack line: overall average"
  ) +
  custom_theme +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "bottom"
  )


```

## 4. Calibration Wafer Analysis

```{r calibration_wafer_analysis}
new_calibration_factors<- calibration_summary_data %>%
  group_by(Sample, Trial) %>%
  summarise(
    Total_Width = sum(edge_width),
    .groups = "drop"
  )

max_width <- max(new_edge_factors$Total_Width)

new_calibration_factors <- new_calibration_factors %>%
  mutate(Factors = max_width/Total_Width)


calibration_summary_data <- calibration_summary_data %>%
  group_by(Sample, Trial) %>%
  mutate(
    Image = row_number(),
    CumulativeCount = cumsum(Count)
  ) %>%
  ungroup()

calibration_particles_data <- calibration_particles_data %>%
  group_by(Sample, Trial) %>%
  mutate(
    ParticleIndex = row_number(),
    Image = findInterval(ParticleIndex, calibration_summary_data$CumulativeCount[calibration_summary_data$Sample == first(Sample) & calibration_summary_data$Trial == first(Trial)]) + 1
  ) %>%
  ungroup()

# Calculate area-based counts for calibration data
calibration_counts <- calibration_particles_data %>%
  group_by(Trial, Sample) %>%
  group_modify(~ {
    norm_factor <- new_calibration_factors$Factors[new_calibration_factors$Sample == .y$Sample & new_calibration_factors$Trial == .y$Trial]
    counts <- get_area_counts(.x, norm_factor)
    tibble(
      Area = area_thresholds,
      Count = counts
    )
  })

# Calculate cumulative counts
cumulative_calibration_counts <- calibration_counts %>%
  group_by(Trial, Sample) %>%
  arrange(desc(Area)) %>%
  mutate(Cumulative_Count = cumsum(Count)) %>%
  ungroup()

# Calculate average counts by trial
average_calibration_counts <- cumulative_calibration_counts %>%
  group_by(Trial, Area) %>%
  summarize(
    Average_Count = round(mean(Cumulative_Count, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  mutate(Trial = Trial + 5) %>%  # Adjust trial numbers to match other analyses
  arrange(Trial, desc(Area)) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Average_Count),
         log_count = ifelse(log_count < 0, 0, log_count))

# Calculate best fit lines
calibration_best_fits <- average_calibration_counts %>%
  group_by(Trial) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Average_Count),
         log_count = ifelse(log_count < 0, 0, log_count)) %>%
  summarise(
    slope = coef(lm(log_count ~ log_area))[2],
    intercept = coef(lm(log_count ~ log_area))[1],
    .groups = "drop"
  ) %>%
  mutate(PCL = 10^(-intercept/slope))

# For cumulative data - calculate the overall average across all trials
overall_average_calibration <- average_calibration_counts %>%
  group_by(log_area) %>%
  summarize(
    Average_Count = mean(log_count, na.rm = TRUE),
    .groups = "drop"
  )

# Modify the cumulative distribution plot
ggplot() +
  geom_line(data = average_calibration_counts,
            aes(x = log_area, y = log_count,
                color = factor(Trial))) +
  geom_line(data = overall_average_calibration,
            aes(x = log_area, y = Average_Count),
            color = "black", size = 1.2) +  # Add distinct average line
  geom_abline(data = calibration_best_fits,
              aes(slope = slope, intercept = intercept,
                  color = factor(Trial)),
              linetype = "dotted") +
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(log[10](Area)~"(square microns)"),
    y = "log10(Particle Count)",
    title = "Calibration Wafer Analysis: Particle Area Distribution",
    subtitle = "Solid lines: observed data, Dotted lines: fitted curves, Black line: overall average"
  ) +
  custom_theme

# Display calibration analysis statistics
kable(calibration_best_fits,
      caption = "Calibration Wafer Analysis Summary Statistics")


average_calibration_binned <- average_calibration_counts %>%
  group_by(Trial) %>%
  arrange(desc(Area)) %>%  # Ensure data is sorted by descending area
  mutate(
    Count = c(Average_Count[1], diff(Average_Count))  # First value is the total, then differences
  ) %>%
  ungroup() %>% 
  mutate(log_count_bin = log10(Count),
         log_count_bin = ifelse(log_count_bin < 0, 0, log_count_bin))

# Calculate overall average binned counts
overall_average_calibration_binned <- average_calibration_binned %>%
  group_by(Area) %>%
  summarize(
    Average_Count = mean(Count, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    log_area = log10(Area),
    log_count = log10(Average_Count),
    log_count = ifelse(log_count < 0 | !is.finite(log_count), 0, log_count)
  )



# Modify the binned distribution plot
ggplot() +
  geom_line(data = average_calibration_binned, 
            aes(x = log_area, y = log_count_bin, 
                color = factor(Trial))) +
  geom_line(data = overall_average_calibration_binned,
            aes(x = log_area, y = log_count),
            color = "black", size = 1.2) +  # Add distinct average line
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(Area~"(square microns)"),
    y = "Average Particle Count",
    title = "Calibration Wafer Analysis: Binned Particle Size Distribution",
    subtitle = "Particles binned by logarithmic area thresholds\nBlack line: overall average"
  ) +
  custom_theme +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "bottom"
  )

```

## 5. Edge Model Analysis

```{r edge_model_analysis}

new_sample_areas <- surface_before_data$summary_data %>%
  group_by(Sample, Trial, Cleaning_Method) %>%
  summarise(
    Total_Images = n(),
    Total_Area = n() * image_size * 1e-12,  # Convert to m^2
    .groups = "drop"
  )

# New function to sum areas within thresholds

get_area_sums <- function(data, normalization_factor) {
  sapply(area_thresholds, function(x) {
    sum(data$Area[data$Area > x], na.rm = TRUE) * normalization_factor
  })
}

# Calculate model parameters using area summation
surface_area <- surface_after_data$particle_data %>%
  group_by(Trial, Sample) %>%
  group_modify(~ {
    norm_factor <- 0.1 / new_sample_areas$Total_Area[new_sample_areas$Sample == .y$Sample & new_sample_areas$Trial == .y$Trial]
    areas <- get_area_sums(.x, norm_factor)
    tibble(
      Area = area_thresholds,
      Total_Area = areas
    )
  }) %>%
  group_by(Trial, Area) %>%  # Group by both Trial and Area
  summarize(
    Average_Total_Area = mean(Total_Area, na.rm = TRUE),
    .groups = "drop"
  ) 




# Calculate model parameters using area-based approach
edge_model_data <- surface_area %>%
  mutate(
    Normalized_Area = (Average_Total_Area) / (.1 * 10^12),
    Model_Count = (4 * Normalized_Area) / sqrt(pi * (2*(sqrt(Area/pi))))
  ) %>%
  group_by(Trial) %>%
  arrange(desc(Area)) %>%
  mutate(Cumulative_Count = cumsum(Model_Count)) %>%
  ungroup()

# Normalize counts by maximum edge length
edge_model_data <- edge_model_data %>%
  mutate(
    Normalized_Count = Model_Count * max_width,
    Normalized_Cumulative_Count = round(Cumulative_Count * max_width)
  ) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Normalized_Cumulative_Count),
         Normalized_Cumulative_Count = ifelse(log_count < 0, 0, log_count))

# Calculate best fit lines for the model
model_best_fits <- edge_model_data %>%
  group_by(Trial) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Normalized_Cumulative_Count),
         log_count = ifelse(log_count < 0, 0, log_count)) %>%
  summarise(
    slope = coef(lm(log_count ~ log_area))[2],
    intercept = coef(lm(log_count ~ log_area))[1],
    .groups = "drop"
  ) %>%
  mutate(PCL = 10^(-intercept/slope))

overall_average_model <- edge_model_data %>%
  group_by(log_area) %>%
  summarize(
    Average_Count = mean(Normalized_Cumulative_Count, na.rm = TRUE),
    .groups = "drop"
  )

# Create edge model visualization
ggplot() +
  geom_line(data = edge_model_data,
            aes(x = log_area, y = Normalized_Cumulative_Count,
                color = factor(Trial))) +
  geom_line(data = overall_average_model,
            aes(x = log_area, y = Average_Count),
            color = "black", size = 1.2) +  
  geom_abline(data = model_best_fits,
              aes(slope = slope, intercept = intercept,
                  color = factor(Trial)),
              linetype = "dotted") +
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(log[10](Area)~"(square microns)"),
    y = "log10(Particle Count)",
    title = "Edge Model Analysis: Particle Area Distribution",
    subtitle = "Solid lines: modeled data, Dotted lines: fitted curves, Black line: overall average"
  ) +
  custom_theme


# Display model statistics
kable(model_best_fits %>%
        select(Trial, PCL, slope),
      caption = "Edge Model Analysis Summary Statistics")

# Function to get binned counts
get_binned_counts <- function(data, normalization_factor) {
  # Create bins using the area thresholds
  bins <- cut(data$Area, 
              breaks = c(0, area_thresholds), 
              labels = area_thresholds,
              include.lowest = TRUE)
  
  # Count particles in each bin and normalize
  counts <- table(bins) * normalization_factor
  return(counts)
}

# Calculate binned areas and model counts for surface data
surface_model_binned <- surface_after_data$particle_data %>%
  group_by(Trial, Sample) %>%
  group_modify(~ {
    norm_factor <- 0.1 / new_sample_areas$Total_Area[
      new_sample_areas$Sample == .y$Sample & 
      new_sample_areas$Trial == .y$Trial
    ]
    counts <- get_binned_counts(.x, norm_factor)
    tibble(
      Area = as.numeric(names(counts)),
      Count = as.numeric(counts)
    )
  })

# Calculate model parameters for each bin
edge_model_binned <- surface_model_binned %>%
  mutate(
    Area_um2 = Area,  # Keep original area for reference
    Area_m2 = Area * 1e-12,  # Convert to m^2
    Normalized_Area = (Count * Area_m2) / (.1),
    Model_Count = (4 * Normalized_Area) / sqrt(pi * (2*(sqrt(Area_um2/pi))))
  ) %>%
  mutate(
    Normalized_Count = Model_Count * max_width
  )

# Calculate average counts by trial
average_model_binned <- edge_model_binned %>%
  group_by(Trial, Area) %>%
  summarize(
    Average_Count = round(mean(Normalized_Count, na.rm = TRUE)),
    .groups = "drop"
  ) %>%
  mutate(log_area = log10(Area),
         log_count = log10(Average_Count),
         log_count = ifelse(log_count < 0, 0, log_count))

overall_average_model_binned <- average_model_binned %>%
  group_by(log_area) %>%
  summarize(
    Average_Count = mean(log_count, na.rm = TRUE),
    .groups = "drop"
  )

ggplot() +
  geom_line(data = average_model_binned, 
            aes(x = log_area, y = log_count, 
                color = factor(Trial))) +
  geom_line(data = overall_average_model_binned,
            aes(x = log_area, y = Average_Count),
            color = "black", size = 1.2) +
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(Area~"(square microns)"),
    y = "Average Model Particle Count",
    title = "Edge Model Analysis: Binned Particle Size Distribution",
    subtitle = "Particles binned by area thresholds\nBlack line: overall average"
  ) +
  custom_theme +
  theme(
    panel.grid.minor = element_blank(),
    legend.position = "bottom"
  )

```

## 6. Combined Analysis and Comparison

```{r combined_analysis, fig.width=10, fig.height=6}

# Create a combined plot with observed data, edge model, and calibration data
ggplot() +
  # Observed data
  geom_line(data = average_edge_counts, 
            aes(x = log_area, y = log_count, 
                color = factor(Trial)), 
            linetype = line_types["Observed"]) +
  # Edge model
  geom_line(data = edge_model_data,
            aes(x = log_area, y = Normalized_Cumulative_Count, 
                color = factor(Trial)),
            linetype = line_types["Modeled"]) +
  # Calibration data
  geom_line(data = average_calibration_counts,
            aes(x = log_area, y = log_count, 
                color = factor(Trial)),
            linetype = line_types["Calibration"]) +
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(log[10](Area)~"(microns)"),
    y = "log10(Particle Count)",
    title = "Distribution of Particles by Trial",
    subtitle = "Solid: Observed, Dashed: Edge Model, Dotted: Calibration"
  ) +
  custom_theme

## Comparative Means
comparison_mean_dist <- average_edge_counts %>% 
  full_join(edge_model_data[,c(1,2,8)], by = c("Trial", "Area")) %>% 
  full_join(average_calibration_counts, by = c("Trial", "Area")) %>% 
  mutate(
    Observed_edge_counts = log_count.x,
    Modeled_edge_counts = Normalized_Cumulative_Count,
    Observed_Calibration_counts = log_count.y
  ) %>% 
  select(Trial, log_area.x, Observed_edge_counts, Modeled_edge_counts, Observed_Calibration_counts) %>%
  group_by(log_area.x) %>%
  summarize(
    Observed_edge_counts = mean(Observed_edge_counts, na.rm = F),
    Modeled_edge_counts = mean(Modeled_edge_counts, na.rm = F),
    Observed_Calibration_counts = mean(Observed_Calibration_counts, na.rm = F), 
    .groups = "drop")
  #  %>% 
  # mutate(
  #   Modeled_edge_with_adhesion_counts = round(Modeled_edge_counts/(2*(sqrt(Area/pi)))),
  #   Calibration_with_adhesion_counts = round(Observed_Calibration_counts/(2*(sqrt(Area/pi))))
  # )

# Mean distribution plot
ggplot() +
  geom_line(data = comparison_mean_dist, 
            aes(x = log_area.x, y = Observed_edge_counts),
            color = trial_colors["6"]) +
  geom_line(data = comparison_mean_dist, 
            aes(x = log_area.x, y = Modeled_edge_counts),
            color = trial_colors["8"]) +
  geom_line(data = comparison_mean_dist, 
            aes(x = log_area.x, y = Observed_Calibration_counts),
            color = trial_colors["9"]) +
  # geom_line(data = comparison_mean_dist, 
  #           aes(x = log10(Area), y = log10(Modeled_edge_with_adhesion_counts)),
  #           color = trial_colors["8"], 
  #           linetype = "dashed") +
  # geom_line(data = comparison_mean_dist, 
  #           aes(x = log10(Area), y = log10(Calibration_with_adhesion_counts)),
  #           color = trial_colors["9"], 
  #           linetype = "dashed") +
  labs(
    x = expression(log[10](Area)~"(microns)"),
    y = "log10(Particle Count)",
    title = "Distribution of Particles by Model",
    subtitle = "Red: Observed Edge Counts, Blue: Modeled Edge Counts, Green: Observed Calibration Counts, \n Blue-dashed: Modeled Edge Counts with Adhesion Factor, Green-dashed: Observed Calibration Counts with Adhesion Factor"
  ) +
  custom_theme

## Comparison Ratios
comparison_all_models <- average_edge_counts %>% 
  full_join(edge_model_data[,c(1,2,8)], by = c("Trial", "Area")) %>% 
  full_join(average_calibration_counts, by = c("Trial", "Area")) %>% 
  mutate(
    Observed_edge_counts = log_count.x,
    Modeled_edge_counts = Normalized_Cumulative_Count,
    Observed_Calibration_counts = log_count.y
  ) %>% 
  select(Trial, log_area.x, Observed_edge_counts, Modeled_edge_counts, Observed_Calibration_counts) %>% 
  mutate(
    Ratio = 1/(2*(sqrt(10^(log_area.x)/pi))),
    Observed_by_Modeled = Observed_edge_counts/Modeled_edge_counts,
    Observed_by_Calibration = Observed_edge_counts/Observed_Calibration_counts,
    Modeled_by_Calibration = Modeled_edge_counts/Observed_Calibration_counts
  ) %>% 
  group_by(log_area.x) %>%
  summarize(
    Observed_by_Modeled = mean(Observed_by_Modeled, na.rm = TRUE),
    Observed_by_Calibration = mean(Observed_by_Calibration, na.rm = TRUE),
    Modeled_by_Calibration = mean(Modeled_by_Calibration, na.rm = TRUE), 
    Ratio = mean(Ratio, na.rm = TRUE), 
    .groups = "drop"
  ) 

#Ratio comparison plot
ggplot() +
  geom_line(data = comparison_all_models,
            aes(x = log_area.x, y = Observed_by_Modeled),
            color = trial_colors["6"]) +
  geom_line(data = comparison_all_models,
            aes(x = log_area.x, y = Observed_by_Calibration),
            color = trial_colors["8"]) +
  geom_line(data = comparison_all_models,
            aes(x = log_area.x, y = Ratio),
            color = trial_colors["9"]) +
  labs(
    x = expression(log[10](Area)~"(microns)"),
    y = "Ratio",
    title = "Ratio of Particles per Experiment",
    subtitle = "Comparison of measurement methods against theoretical ratio"
  ) +
  custom_theme

# Model comparison table
model_comparison_table <- comparison_all_models %>% summary()

kable(model_comparison_table, 
      caption = "Statistical Summary of Model Comparisons")


# Define line types for different data sources
line_types <- c(
  "Observed" = "solid",
  "Modeled" = "dashed",
  "Calibration" = "dotted"
)

# Create a combined plot with all binned data
ggplot() +
  # Observed edge data
  geom_line(data = average_edge_binned, 
            aes(x = log_area, y = log_count, 
                color = factor(Trial)), 
            linetype = line_types["Observed"]) +
  # Edge model data
  geom_line(data = average_model_binned,
            aes(x = log_area, y = log_count, 
                color = factor(Trial)),
            linetype = line_types["Modeled"]) +
  # Calibration data
  geom_line(data = average_calibration_binned,
            aes(x = log_area, y = log_count, 
                color = factor(Trial)),
            linetype = line_types["Calibration"]) +
  scale_color_manual(values = trial_colors, name = "Trial") +
  labs(
    x = expression(log[10](Area)~"(microns)"),
    y = "log10(Particle Count)",
    title = "Binned Distribution of Particles by Trial",
    subtitle = "Solid: Observed Edge, Dashed: Edge Model, Dotted: Calibration"
  ) +
  custom_theme

# Calculate mean distributions for binned data
binned_mean_dist <- average_edge_binned %>% 
  full_join(average_model_binned, by = c("Trial", "Area"), suffix = c("_edge", "_model")) %>% 
  full_join(average_calibration_binned, by = c("Trial", "Area")) %>% 
  group_by(log_area) %>%
  summarize(
    Observed_edge_counts = mean(log_count_edge, na.rm = TRUE),
    Modeled_edge_counts = mean(log_count_model, na.rm = TRUE),
    Observed_Calibration_counts = mean(log_count, na.rm = TRUE),
    .groups = "drop"
  ) %>% 
  mutate(
    Modeled_edge_with_adhesion_counts = Modeled_edge_counts/(2*(sqrt(10^(log_area)/pi))),
    Calibration_with_adhesion_counts = Observed_Calibration_counts/(2*(sqrt(10^(log_area)/pi)))
  )

# Create mean distribution plot for binned data
ggplot() +
  geom_line(data = binned_mean_dist, 
            aes(x = log_area, y = Observed_edge_counts),
            color = trial_colors["6"]) +
  geom_line(data = binned_mean_dist, 
            aes(x = log_area, y = Modeled_edge_counts),
            color = trial_colors["8"]) +
  geom_line(data = binned_mean_dist, 
            aes(x =log_area, y = Observed_Calibration_counts),
            color = trial_colors["9"]) +
  # geom_line(data = binned_mean_dist, 
  #           aes(x = log10(Area), y = log10(Modeled_edge_with_adhesion_counts)),
  #           color = trial_colors["8"], 
  #           linetype = "dashed") +
  # geom_line(data = binned_mean_dist, 
  #           aes(x = log10(Area), y = log10(Calibration_with_adhesion_counts)),
  #           color = trial_colors["9"], 
  #           linetype = "dashed") +
  labs(
    x = expression(log[10](Area)~"(microns)"),
    y = "log10(Particle Count)",
    title = "Binned Distribution of Particles by Model",
    subtitle = "Red: Observed Edge, Blue: Modeled Edge, Green: Calibration\nDashed lines include adhesion factor"
  ) +
  custom_theme

# Calculate ratios for binned data
binned_ratios <- average_edge_binned %>% 
  full_join(average_model_binned, by = c("Trial", "Area"), suffix = c("_edge", "_model")) %>% 
  full_join(average_calibration_binned, by = c("Trial", "Area")) %>% 
  mutate(
    Ratio = 1/(2*(sqrt(10^(log_area)/pi))),
    Observed_by_Modeled = log_count_edge/log_count_model,
    Observed_by_Calibration = log_count_edge/log_count,
    Modeled_by_Calibration = log_count_model/log_count
  ) %>% 
  group_by(log_area) %>%
  summarize(
    Observed_by_Modeled = mean(Observed_by_Modeled, na.rm = TRUE),
    Observed_by_Calibration = mean(Observed_by_Calibration, na.rm = TRUE),
    Modeled_by_Calibration = mean(Modeled_by_Calibration, na.rm = TRUE),
    Ratio = mean(Ratio, na.rm = TRUE),
    .groups = "drop"
  )

# Create ratio plot for binned data
ggplot() +
  geom_line(data = binned_ratios,
            aes(x = log_area, y = Observed_by_Modeled),
            color = trial_colors["6"]) +
  geom_line(data = binned_ratios,
            aes(x = log_area, y = Observed_by_Calibration),
            color = trial_colors["8"]) +
  geom_line(data = binned_ratios,
            aes(x = log_area, y = Ratio),
            color = trial_colors["9"]) +
  labs(
    x = expression(log[10](Area)~"(microns)"),
    y = "Ratio",
    title = "Ratio of Binned Particles per Experiment",
    subtitle = "Red: Observed/Modeled, Blue: Observed/Calibration, Green: Theoretical Ratio"
  ) +
  custom_theme


```


```{r}


# Calculate surface binned fit
surface_binned_fit <- overall_average_surface_binned %>%
  summarise(
    slope = coef(lm(Average_Count ~ log_area))[2],
    intercept = coef(lm(Average_Count ~ log_area))[1],
    .groups = "drop"
  ) %>%
  mutate(PCL = 10^(sqrt(-intercept/slope)))
#logN = -0.926(log2 (x) - log2 (PCL))



# For calibration data
calibration_normalized <- overall_average_calibration_binned %>% 
  mutate(
    Total_Count = sum(10^Average_Count, na.rm = TRUE),
    Normalized_Count = 10^Average_Count / Total_Count) 
  
# For edge data
edge_normalized <- overall_average_binned %>%
  mutate(
    Total_Count = sum(10^log_count, na.rm = TRUE),
    Normalized_Count = 10^log_count / Total_Count ) 




# First, create Figure 15 (Etched Samples)
# Modify theme for better match
plot_theme <- theme_minimal() +
  theme(
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_line(color = "gray95"),
    text = element_text(size = 10),
    legend.position = "top",
    legend.text = element_text(size = 8),
    plot.title = element_text(size = 12, hjust = 0.5),
    plot.subtitle = element_text(size = 10, hjust = 0.5)
  )

# Surface Plot
p1 <- ggplot() +
  geom_line(data = overall_average_surface_binned,
            aes(x = 10^log_area, y = 10^Average_Count),
            color = "#0072BD") +
  geom_abline(
    data = surface_binned_fit,
    aes(slope = slope, intercept = intercept),
    linetype = "dashed",
    color = "black"
  ) +
  scale_x_log10(
    limits = c(10, 1e5),
    breaks = 10^(1:5),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1, 1e6),
    breaks = 10^(0:6)
  ) +
  labs(
    x = expression("Overhanging Particle Area ("*mu*m^2*")"),
    y = "# Surface Particles"
  ) +
  plot_theme +
  annotate(
    "text",
    x = 100,
    y = 1e5,
    label = sprintf("IEST Fit: PCL %d, slope %.2f",
                   round(surface_binned_fit$PCL),
                   surface_binned_fit$slope),
    hjust = 0
  )

# Edge Plot
p2 <- ggplot() +
  geom_line(data = overall_average_binned,
            aes(x = 10^log_area, y = 10^log_count),
            color = "#0072BD") +
  geom_line(data = overall_average_model_binned,
            aes(x = 10^log_area, y = 10^Average_Count),
            color = "#D95319") +
  geom_line(data = overall_average_model_binned,
            aes(x = 10^log_area, y = (10^Average_Count)/(2*(sqrt(10^(log_area)/pi)))),
            color = "#7E2F8E",
            linetype = "dotted") +
  scale_x_log10(
    limits = c(10, 1e5),
    breaks = 10^(1:5),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1, 1e3),
    breaks = 10^(0:3)
  ) +
  labs(
    x = expression("Overhanging Particle Area ("*mu*m^2*")"),
    y = "# Edge Particles"
  ) +
  plot_theme

# Arrange plots side by side with main title
figure_15 <- grid.arrange(
  p1, p2,
  ncol = 2,
  top = textGrob("Etched Samples", gp = gpar(fontsize = 14, fontface = "bold"))
)

# Now create Figure 16 (Comparative Analysis)
# Normalized Distribution Plot
p3 <- ggplot() +
  geom_line(data = calibration_normalized,
            aes(x = 10^log_area, y = Normalized_Count),
            color = "#0072BD") +
  geom_line(data = edge_normalized,
            aes(x = 10^log_area, y = Normalized_Count),
            color = "#D95319") +
  scale_x_log10(
    limits = c(10, 1e4),
    breaks = c(10, 100, 1000, 10000),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1e-4, 1),
    breaks = 10^seq(-4, 0, by = 1)
  ) +
  labs(
    x = expression("Particle Area ("*mu*m^2*")"),
    y = "Proportion of Particulates",
    title = "Normalized Edge Particulate Distributions"
  ) +
  plot_theme

# Ratio Plot
p4 <- ggplot() +
  geom_line(data = binned_ratios,
            aes(x = log_area, y = Observed_by_Calibration),
            color = "#0072BD") +
  geom_line(data = binned_ratios,
            aes(x = log_area, y = Ratio),
            color = "#D95319",
            linetype = "dashed") +
  scale_x_continuous(
    limits = c(0, 4)) +
  scale_y_continuous(
    limits = c(0, 2),
    breaks = seq(0, 2, 0.5)
  ) +
  labs(
    x = expression("Particle Area ("*mu*m^2*")"),
    y = "Edge Particulate Ratio\nEtched/Calibration",
    title = "Missing Edge Particulate Ratio"
  ) +
  plot_theme

# Arrange plots side by side
figure_16 <- grid.arrange(
  p3, p4,
  ncol = 2,
  top = textGrob("Comparative Analysis", gp = gpar(fontsize = 14, fontface = "bold"))
)
```

```{r}

create_image_grob <- function(img_path) {
  img <- readPNG(img_path)
  rasterGrob(img, interpolate = TRUE)
}

# Function to create text grob for labels
create_label <- function(text) {
  textGrob(text, gp = gpar(fontsize = 12, fontface = "bold"))
}


# Figure 15 Comparison
grid.arrange(
  create_image_grob("/Users/brandontitensor/Desktop/College/Research/Dust_Contamination/starshade_dust_particle/data_analysis/Figure_15.png"),
  arrangeGrob(p1, p2, ncol = 2),
  ncol = 1,
  heights = c(1, 1),
  top = textGrob("Figure 15: Etched Samples Comparison", 
                 gp = gpar(fontsize = 14, fontface = "bold"))
)

# Create layout for comparison
compare_plots <- function(reference_img, generated_plot, title) {
  grid.arrange(
    reference_img, generated_plot,
    ncol = 2,
    top = textGrob(title, gp = gpar(fontsize = 14, fontface = "bold")),
    widths = c(1, 1)
  )
}

# Figure 16 Comparison
grid.arrange(
  create_image_grob("/Users/brandontitensor/Desktop/College/Research/Dust_Contamination/starshade_dust_particle/data_analysis/Figure_16.png"),
  arrangeGrob(p3, p4, ncol = 2),
  ncol = 1,
  heights = c(1, 1),
  top = textGrob("Figure 16: Comparative Analysis Comparison", 
                 gp = gpar(fontsize = 14, fontface = "bold"))
)

```

```{r,eval = F}
# Calculate surface binned fit using consistent approach with earlier analysis
surface_binned_fit <- overall_average_surface_binned %>%
  filter(!is.na(Average_Count), !is.infinite(Average_Count)) %>%
  summarise(
    slope = coef(lm(Average_Count ~ log_area))[2],
    intercept = coef(lm(Average_Count ~ log_area))[1],
    .groups = "drop"
  ) %>%
  mutate(PCL = 10^(-intercept/slope))

# Calculate IEST fit prediction for edge with proper scaling
edge_iest_prediction <- average_surface_all_trials %>%
  mutate(
    # Use the geometric factor for edge prediction
    Predicted_Count = 10^(surface_binned_fit$intercept + surface_binned_fit$slope * log10(Area)) / 
      (2 * sqrt(Area/pi))
  ) %>%
  filter(!is.na(Predicted_Count), !is.infinite(Predicted_Count))

# Normalize calibration data consistently with binning approach
calibration_normalized <- overall_average_calibration_binned %>% 
  mutate(
    # Calculate total count excluding NA and infinite values
    Total_Count = sum(10^Average_Count[!is.na(Average_Count) & !is.infinite(Average_Count)], 
                     na.rm = TRUE),
    # Normalize counts
    Normalized_Count = 10^Average_Count / Total_Count
  ) %>%
  filter(!is.na(Normalized_Count), !is.infinite(Normalized_Count))

# Normalize edge data with consistent approach
edge_normalized <- overall_average_binned %>%
  mutate(
    # Calculate total count excluding NA and infinite values
    Total_Count = sum(10^log_count[!is.na(log_count) & !is.infinite(log_count)], 
                     na.rm = TRUE),
    # Normalize counts
    Normalized_Count = 10^log_count / Total_Count
  ) %>%
  filter(!is.na(Normalized_Count), !is.infinite(Normalized_Count))

# Calculate average model with adhesion factor
average_model_with_adhesion <- edge_model_data %>%
  group_by(Area) %>%
  summarise(
    Average_Count = mean(Normalized_Cumulative_Count, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    # Apply adhesion factor
    Average_Count_with_adhesion = Average_Count / (2 * sqrt(Area/pi))
  ) %>%
  filter(!is.na(Average_Count_with_adhesion), !is.infinite(Average_Count_with_adhesion))

# Prepare binned ratios with proper filtering and calculations
binned_ratios <- average_edge_binned %>% 
  full_join(average_model_binned, 
            by = c("Trial", "Area", "log_area"), 
            suffix = c("_edge", "_model")) %>% 
  full_join(average_calibration_binned, 
            by = c("Trial", "Area", "log_area")) %>%
  mutate(
    # Calculate theoretical ratio
    Ratio = 1/(2 * sqrt(10^log_area/pi)),
    # Calculate observed ratios
    Observed_by_Calibration = 10^log_count_edge / 10^log_count,
    # Filter out invalid values
    Observed_by_Calibration = ifelse(is.infinite(Observed_by_Calibration) | 
                                   is.na(Observed_by_Calibration), 
                                   NA, 
                                   Observed_by_Calibration)
  ) %>%
  group_by(log_area) %>%
  summarize(
    Observed_by_Calibration = mean(Observed_by_Calibration, na.rm = TRUE),
    Ratio = mean(Ratio, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(!is.na(Observed_by_Calibration), 
         !is.infinite(Observed_by_Calibration),
         !is.na(Ratio),
         !is.infinite(Ratio))



# Surface Plot (p1)
p1 <- ggplot() +
  geom_line(data = overall_average_surface_binned,
            aes(x = 10^log_area, y = 10^Average_Count),
            color = trial_colors["8"]) +
  geom_abline(
    data = surface_binned_fit,
    aes(slope = slope, intercept = intercept),
    linetype = "dashed",
    color = "black"
  ) +
  scale_x_log10(
    limits = c(10, 1e5),
    breaks = 10^(1:5),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1, 1e6),
    breaks = 10^(0:6)
  ) +
  labs(
    x = expression("Overhanging Particle Area ("*mu*m^2*")"),
    y = "# Surface Particles",
    title = "Surface Particle Distribution"
  ) +
  custom_theme +
  annotate(
    "text",
    x = 100,
    y = 1e5,
    label = sprintf("IEST Fit: PCL %d, slope %.2f",
                   round(surface_binned_fit$PCL),
                   surface_binned_fit$slope),
    hjust = 0,
    size = 3.5
  )

# Edge Plot (p2)
p2 <- ggplot() +
  geom_line(data = overall_average_binned,
            aes(x = 10^log_area, y = 10^log_count),
            color = trial_colors["8"]) +
  geom_line(data = overall_average_model_binned,
            aes(x = 10^log_area, y = 10^Average_Count),
            color = trial_colors["9"]) +
  geom_line(data = edge_iest_prediction,
            aes(x = Area, y = Predicted_Count),
            color = trial_colors["7"],
            linetype = "dashed") +
  geom_line(data = average_model_with_adhesion,
            aes(x = Area, y = Average_Count_with_adhesion),
            color = trial_colors["10"],
            linetype = "dotted") +
  scale_x_log10(
    limits = c(10, 1e5),
    breaks = 10^(1:5),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1, 1e3),
    breaks = 10^(0:3)
  ) +
  labs(
    x = expression("Overhanging Particle Area ("*mu*m^2*")"),
    y = "# Edge Particles",
    title = "Edge Particle Distribution"
  ) +
  custom_theme

# Normalized Distribution Plot (p3)
p3 <- ggplot() +
  geom_line(data = calibration_normalized,
            aes(x = 10^log_area, y = Normalized_Count),
            color = trial_colors["8"]) +
  geom_line(data = edge_normalized,
            aes(x = 10^log_area, y = Normalized_Count),
            color = trial_colors["9"]) +
  scale_x_log10(
    limits = c(10, 1e4),
    breaks = c(10, 100, 1000, 10000),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1e-4, 1),
    breaks = 10^seq(-4, 0, by = 1)
  ) +
  labs(
    x = expression("Particle Area ("*mu*m^2*")"),
    y = "Proportion of Particulates",
    title = "Normalized Edge Particulate Distributions"
  ) +
  custom_theme +
  theme(legend.position = "none")

# Ratio Plot (p4)
p4 <- ggplot() +
  geom_line(data = binned_ratios,
            aes(x = log_area, y = Observed_by_Calibration),
            color = trial_colors["8"]) +
  geom_line(data = binned_ratios,
            aes(x = log_area, y = Ratio),
            color = trial_colors["9"],
            linetype = "dashed") +
  scale_x_continuous(
    limits = c(0, 4)
  ) +
  scale_y_continuous(
    limits = c(0, 2),
    breaks = seq(0, 2, 0.5)
  ) +
  labs(
    x = expression(log[10]*"(Particle Area) ("*mu*m^2*")"),
    y = "Edge Particulate Ratio\nEtched/Calibration",
    title = "Missing Edge Particulate Ratio"
  ) +
  custom_theme +
  theme(legend.position = "none")

# Create the combined figures using grid.arrange
figure_15 <- grid.arrange(
  p1, p2,
  ncol = 2,
  top = textGrob("Etched Samples", 
                 gp = gpar(fontsize = 14, fontface = "bold"))
)

figure_16 <- grid.arrange(
  p3, p4,
  ncol = 2,
  top = textGrob("Comparative Analysis", 
                 gp = gpar(fontsize = 14, fontface = "bold"))
)
```

```{r, eval = F}
# Calculate surface cumulative fit
surface_cumulative_fit <- overall_average_surface %>%
  filter(!is.na(Average_Count), !is.infinite(Average_Count)) %>%
  summarise(
    slope = coef(lm(Average_Count ~ log_area))[2],
    intercept = coef(lm(Average_Count ~ log_area))[1],
    .groups = "drop"
  ) %>%
  mutate(PCL = 10^(-intercept/slope))

# Calculate IEST fit prediction for edge using cumulative data
edge_iest_prediction <- average_surface_counts %>%
  arrange(Area) %>%
  mutate(
    # Use the geometric factor for edge prediction
    Predicted_Count = 10^(surface_cumulative_fit$intercept + 
                         surface_cumulative_fit$slope * log10(Area)) / 
      (2 * sqrt(Area/pi))
  ) %>%
  filter(!is.na(Predicted_Count), !is.infinite(Predicted_Count))

# Normalize cumulative calibration data
calibration_normalized <- average_calibration_counts %>% 
  arrange(Area) %>%
  mutate(
    Total_Count = sum(10^log_count[!is.na(log_count) & !is.infinite(log_count)], 
                     na.rm = TRUE),
    Normalized_Count = 10^log_count / Total_Count
  ) %>%
  filter(!is.na(Normalized_Count), !is.infinite(Normalized_Count))

# Normalize cumulative edge data
edge_normalized <- average_edge_counts %>%
  arrange(Area) %>%
  mutate(
    Total_Count = sum(10^log_count[!is.na(log_count) & !is.infinite(log_count)], 
                     na.rm = TRUE),
    Normalized_Count = 10^log_count / Total_Count
  ) %>%
  filter(!is.na(Normalized_Count), !is.infinite(Normalized_Count))

# Calculate cumulative model with adhesion factor
average_model_with_adhesion <- edge_model_data %>%
  arrange(Area) %>%
  group_by(Area) %>%
  summarise(
    Average_Count = mean(Normalized_Cumulative_Count, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    Average_Count_with_adhesion = Average_Count / (2 * sqrt(Area/pi))
  ) %>%
  filter(!is.na(Average_Count_with_adhesion), !is.infinite(Average_Count_with_adhesion))

# Calculate cumulative ratios
cumulative_ratios <- average_edge_counts %>%
  full_join(edge_model_data, by = c("Area"), suffix = c("_edge", "_model")) %>%
  full_join(average_calibration_counts, by = c("Area"), suffix = c("", "_cal")) %>%
  mutate(
    Ratio = 1/(2 * sqrt(Area/pi)),
    Observed_by_Calibration = 10^log_count / 10^log_count_cal,
    Observed_by_Calibration = ifelse(is.infinite(Observed_by_Calibration) | 
                                   is.na(Observed_by_Calibration), 
                                   NA, 
                                   Observed_by_Calibration)
  ) %>%
  group_by(log_area.x) %>%
  summarize(
    Observed_by_Calibration = mean(Observed_by_Calibration, na.rm = TRUE),
    Ratio = mean(Ratio, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(!is.na(Observed_by_Calibration), 
         !is.infinite(Observed_by_Calibration),
         !is.na(Ratio),
         !is.infinite(Ratio))

# Surface Plot (p1)
p1 <- ggplot() +
  geom_line(data = overall_average_surface,
            aes(x = 10^log_area, y = 10^Average_Count),
            color = trial_colors["8"]) +
  geom_abline(
    data = surface_cumulative_fit,
    aes(slope = slope, intercept = intercept),
    linetype = "dashed",
    color = "black"
  ) +
  scale_x_log10(
    limits = c(10, 1e5),
    breaks = 10^(1:5),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1, 1e6),
    breaks = 10^(0:6)
  ) +
  labs(
    x = expression("Overhanging Particle Area ("*mu*m^2*")"),
    y = "Cumulative Surface Particles",
    title = "Cumulative Surface Particle Distribution"
  ) +
  custom_theme +
  annotate(
    "text",
    x = 100,
    y = 1e5,
    label = sprintf("IEST Fit: PCL %d, slope %.2f",
                   round(surface_cumulative_fit$PCL),
                   surface_cumulative_fit$slope),
    hjust = 0,
    size = 3.5
  )

# Edge Plot (p2)
p2 <- ggplot() +
  geom_line(data = average_edge_counts,
            aes(x = Area, y = 10^log_count),
            color = trial_colors["8"]) +
  geom_line(data = edge_model_data,
            aes(x = Area, y = Normalized_Cumulative_Count),
            color = trial_colors["9"]) +
  geom_line(data = edge_iest_prediction,
            aes(x = Area, y = Predicted_Count),
            color = trial_colors["7"],
            linetype = "dashed") +
  geom_line(data = average_model_with_adhesion,
            aes(x = Area, y = Average_Count_with_adhesion),
            color = trial_colors["10"],
            linetype = "dotted") +
  scale_x_log10(
    limits = c(10, 1e5),
    breaks = 10^(1:5),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1, 1e3),
    breaks = 10^(0:3)
  ) +
  labs(
    x = expression("Overhanging Particle Area ("*mu*m^2*")"),
    y = "Cumulative Edge Particles",
    title = "Cumulative Edge Particle Distribution"
  ) +
  custom_theme

# Normalized Distribution Plot (p3)
p3 <- ggplot() +
  geom_line(data = calibration_normalized,
            aes(x = Area, y = Normalized_Count),
            color = trial_colors["8"]) +
  geom_line(data = edge_normalized,
            aes(x = Area, y = Normalized_Count),
            color = trial_colors["9"]) +
  scale_x_log10(
    limits = c(10, 1e4),
    breaks = c(10, 100, 1000, 10000),
    labels = scales::scientific_format(digits = 1)
  ) +
  scale_y_log10(
    limits = c(1e-4, 1),
    breaks = 10^seq(-4, 0, by = 1)
  ) +
  labs(
    x = expression("Particle Area ("*mu*m^2*")"),
    y = "Cumulative Proportion of Particulates",
    title = "Normalized Cumulative Edge Particulate Distributions"
  ) +
  custom_theme +
  theme(legend.position = "none")

# Ratio Plot (p4)
p4 <- ggplot() +
  geom_line(data = cumulative_ratios,
            aes(x = log_area.x, y = Observed_by_Calibration),
            color = trial_colors["8"]) +
  geom_line(data = cumulative_ratios,
            aes(x = log_area.x, y = Ratio),
            color = trial_colors["9"],
            linetype = "dashed") +
  scale_x_continuous(
    limits = c(0, 4)
  ) +
  scale_y_continuous(
    limits = c(0, 2),
    breaks = seq(0, 2, 0.5)
  ) +
  labs(
    x = expression(log[10]*"(Particle Area) ("*mu*m^2*")"),
    y = "Cumulative Edge Particulate Ratio\nEtched/Calibration",
    title = "Cumulative Missing Edge Particulate Ratio"
  ) +
  custom_theme +
  theme(legend.position = "none")

# Create the combined figures using grid.arrange
figure_15 <- grid.arrange(
  p1, p2,
  ncol = 2,
  top = textGrob("Cumulative Analysis of Etched Samples", 
                 gp = gpar(fontsize = 14, fontface = "bold"))
)

figure_16 <- grid.arrange(
  p3, p4,
  ncol = 2,
  top = textGrob("Cumulative Comparative Analysis", 
                 gp = gpar(fontsize = 14, fontface = "bold"))
)
```

